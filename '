import { createContext, useContext, useState, ReactNode, Dispatch, SetStateAction, useEffect } from 'react';
import { Page, parseClientPage, parseHelperPage } from '@/lib/utils/types';
import { useAuth } from './AuthContext';

interface NavSidebarContextType {
  setPage: Dispatch<SetStateAction<Page>>
  page: Page,
}

interface NavSidebarProviderProps {
  children: ReactNode
}

const NavSidebarContext = createContext<NavSidebarContextType | undefined>(undefined);
const LOCALSTORAGE_NAV_STATE_KEY = "navPage"

export function NavSidebarProvider({ children }: NavSidebarProviderProps) {
  const { authRoute } = useAuth()
  const defaultPage: Page = authRoute === "client" ? "myPosts" : "tasks"
  const [page, setPage] = useState<Page>(defaultPage);

  // used to avoid race conditions on initial render for page set
  const [hydrated, setHydrated] = useState(false);

  useEffect(() => {
    if (!authRoute) {
      return;
    }

    // get state from local storage
    const prevPageState = localStorage.getItem(LOCALSTORAGE_NAV_STATE_KEY);

    // check if exists, otherwise set it 
    if (!prevPageState) {
      localStorage.setItem(LOCALSTORAGE_NAV_STATE_KEY, page);
    }

    // coerce the string | null type into a Page type through handy runtime helper
    const parsedPage = authRoute == "client" ? parseClientPage(prevPageState ?? "") : parseHelperPage(prevPageState ?? "")

    // update state
    setPage(parsedPage)
  }, [authRoute])

  // cache the most recent page state
  useEffect(() => {
    console.log("changing state", page);
    localStorage.setItem(LOCALSTORAGE_NAV_STATE_KEY, page);
  }, [page])

  const navSidebarVals = {
    page,
    setPage
  };

  return (
    <NavSidebarContext.Provider value={navSidebarVals}>
      {children}
    </NavSidebarContext.Provider>
  )
}

export function useNavbar() {
  const ctx = useContext(NavSidebarContext);

  if (!ctx) {
    throw new Error("Cannot call useNavbar without a NavSidebarProvider");
  }

  return ctx;
}
